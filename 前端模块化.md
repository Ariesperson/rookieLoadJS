

# 前言

要学习这一块的知识之前，首先我们了解下为什么会诞生模块化这一开发方式。JavaScript发展初期，JS的作用是为了实现页面的简单交互逻辑。但是随着CPU和浏览器的发展，前端逻辑也越来越复杂，进而衍生出了使用模块化规范去挂历前端代码的想法。

# 模块化的理解

## 模块是什么？

最简单的理解方式：模块就是 将一个程序 按照一定规则拆分成的一个或多个独立的文件。

模块具有的特性：1.具有相互独立和功能逻辑单一的特性。 2.只对外暴露数据、方法或接口，能被引用和导入 。

## 模块化的发展

### 全局function模式 : 将不同的功能封装成不同的全局函数

```javascript
//功能函数化  
//优点：简单方便
//缺点：命名容易重复和冲突，数据不安全，模块之间关系不清晰。
function add(){
}
function del(){
}
```



### namespace模式 : 简单对象封装

```javascript
//功能以对象的形式封装
//优点：解决了全局function模式的命名问题。
//缺点：外部可修改对象的内部，数据仍不安全。
var role = {
    name:'Gulu',
    aggressivity:100,
    defense:20,
    attack(monsterName,monsterDefense){
        damage=this.aggressivity-monsterDefense
        console.log(name+'对怪物'+monsterName+'造成了'+damage+'的伤害')
    }
}
role.aggressivity = 1000
role.attack('史莱姆','10')
```



### IFE模式：匿名函数自调用(闭包)



```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
</body>
<script src="./aboutModule/Ife.js"></script>
<script type="text/javascript">
    myRole.attack('史莱姆','10')
    myRole.defense('史莱姆','50')
</script>
</html>
```

  

```javascript
   // 功能以对象的形式封装
   // 优点：数据是私有的, 外部只能通过暴露的方法操作.,按需加载.更高复用性,高可维护性.
   // 缺点：请求过多,依赖模糊，难以维护。
// roleAction.js文件
(function(window) {
    let role = {
         name:'Gulu',
         aggressivity:100,
         defense:20,
     }
    //操作数据的函数
    function attack(monsterName,monsterDefense){
         damage=role.aggressivity-monsterDefense
         console.log(role.name+'对怪物'+monsterName+'造成了'+damage+'的伤害')
     }
    function defense(monsterName,monsterAggressivity) {
         damage=monsterAggressivity-role.defense
         console.log(monsterName+'对'+role.name+'造成了'+damage+'的伤害')
    }
    //暴露行为
    window.myRole = { attack, defense } //ES6写法
  })(window)
```

## 模块化的规范

------
### AMD和CMD的区别
AMD -> reqiure.js  
1.AMD的api默认一个当多个用。 
2.依赖前置，异步执行。

CMD -> sea.js
1、CMD的api严格区分，推崇职责单一
2、依赖就近，按需加载，同步执行
### CommonJS
1、Commonjs是拷贝输出，ES6模块化是引用输出
2、Commonjs是运行时加载，ES6模块化是编译时输出接口
3、Commonjs是单个值导出，ES6模块化可以多个值导出
4、Commonjs是动态语法可写在函数体中，ES6模块化静态语法只能写在顶层
5、Commonjs的this是当前模块化，ES6模块化的this是undefined

Node应用就是由模块组成，采用的就是CommonJS模块规范。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。
